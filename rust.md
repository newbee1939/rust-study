## 概要

- Rustの特徴
    - マルチパラダイムプログラミング言語
        - Rust は静的型付け（statically-typed），`式ベース（expression-based）`であり，手続き型・関数型プログラミングの両方を実装できる
        - オブジェクト指向プログラミングも制限付きで実装できる

## 式ベース（expression-based）とは

Rustでは `if`, `match`, `{}` ブロックなど、ほとんどの構文が**値を返す式**として扱われる。

- **文（statement）**：処理を実行するが値を返さない（例：`let x = 5;`）
- **式（expression）**：評価されて値を返す（例：`5 + 3`, `if ... else ...`）

### 例：`if` 式

```rust
// C言語では三項演算子が必要 → int x = condition ? 5 : 10;
// Rustではif自体が値を返せる
let x = if condition { 5 } else { 10 };
```

### セミコロンの有無で意味が変わる

```rust
let a = { 5 + 3 };   // a は 8（セミコロンなし → 値を返す）
let b = { 5 + 3; };  // b は ()（セミコロンあり → 値を返さない）

fn add(x: i32, y: i32) -> i32 {
    x + y  // セミコロンなし = returnなしで値を返せる
}
```

### メリット

- コードが簡潔になる（一時変数や `return` を減らせる）
- `let mut` を使わずに条件分岐の結果を代入できる

## ブロック

`{}` で囲まれた式で、**最後の式の値を返す**。

```rust
let a = { 5 };      // a は 5
let b = {};         // b は () (ユニット)
```

### 2つの役割

1. **スコープを作る** - 変数の有効範囲を限定
2. **複数の文をまとめる** - `{ 文; 文; 式 }` の形式

### ポイント

- セミコロン `;` をつけると**式が文になる**（値を返さなくなる）
- 最後の式にセミコロンがないと、その値がブロックの戻り値になる
- 値を返さない（または省略した）場合は `()` を返す
