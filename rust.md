## 概要

> 参考: https://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/6d5875

### Rustってどんな言語？

Rustは「安全で速いプログラムを書ける」ことを目指したプログラミング言語です。

- **静的型付け** … 変数の型（数値なのか文字列なのか等）をプログラムの実行前にチェックしてくれる。typo（打ち間違い）などのミスを事前に防げる
- **式ベース** … `if` やブロック `{}` など、多くの構文が「値を返す」ように書ける（後で詳しく説明します）
- **いろんな書き方ができる** … 手続き型（上から順に処理する書き方）や関数型（関数を組み合わせる書き方）など、複数のスタイルで書ける

---

## 式ベース（expression-based）とは

プログラムのコードは、大きく分けると**「文」**と**「式」**の2種類があります。

| 種類 | 説明 | 例 |
|------|------|------|
| **文（statement）** | 「〜しなさい」という命令。値は返さない | `let x = 5;` |
| **式（expression）** | 計算して**値を返す**もの | `5 + 3` → 8 を返す |

### Rustがすごいところ：`if` が値を返せる！

多くの言語では `if` は「条件によって処理を分岐させるだけ」ですが、Rustでは `if` 自体が**値を返す式**として使えます。

```rust
// 他の言語（例：C言語）では三項演算子が必要
// int x = condition ? 5 : 10;

// Rustでは if がそのまま値を返せる！
let x = if condition { 5 } else { 10 };
// → condition が true なら x = 5、false なら x = 10
```

こう書けると、一時変数を用意したり `let mut`（あとで変更できる変数）を使う必要がなくなり、**コードがスッキリ**します。

### 要注意！セミコロン `;` の有無で意味が変わる

Rustでは、セミコロンをつけるかつけないかで「値を返すか返さないか」が変わります。これは最初つまずきやすいポイントです。

```rust
// セミコロンなし → 値を返す（式のまま）
let a = { 5 + 3 };   // a は 8

// セミコロンあり → 値を返さない（文になってしまう）
let b = { 5 + 3; };  // b は ()（「何もない」を意味する特殊な値）
```

関数でも同じルールが適用されます。

```rust
fn add(x: i32, y: i32) -> i32 {
    x + y  // ← セミコロンなし！これが戻り値になる
    // return x + y; と書いてもOKだけど、Rustでは省略するのが一般的
}
```

> **覚え方**: セミコロン `;` は「ここで終わり！」という意味。つけると値が捨てられてしまう。

---

## ブロック `{}`

`{}` で囲んだ部分を**ブロック**と呼びます。ブロックの中には複数の処理を書くことができ、**最後の式の値**がブロック全体の値になります。

```rust
let a = { 5 };      // ブロックの中は 5 だけ → a は 5
let b = {};         // ブロックの中が空っぽ → b は ()（ユニット型＝何もない値）
```

### ブロックの使いどころ

1. **変数のスコープ（有効範囲）を限定したいとき** … ブロック内で作った変数はブロックの外からは使えない
2. **複数の処理をひとまとめにしたいとき** … `{ 処理1; 処理2; 最後の式 }` のように書く

### おさらい：ブロック内のセミコロン

- 途中の処理にはセミコロン `;` をつける（文として扱う）
- **最後の式**にセミコロンをつけなければ、その値がブロックの戻り値になる
- セミコロンをつけると `()`（何もない値）が返る

---

## オブジェクト

Rustでは**すべての値がオブジェクト**です。

「オブジェクト」というと難しく聞こえますが、要するに**型を持った値**のことです。数値 `1` も、文字列 `"hello"` も、関数も、すべてオブジェクトです。

```rust
let a = 1;       // 1 は数値（i32型）のオブジェクト
let b = { 1 };   // ブロック { 1 } も 1 を返す → a と b は同じ値

// つまり 1 == {1} が成り立つ！
```

> **ポイント**: Rustでは「値」と「オブジェクト」はほぼ同じ意味だと思ってOKです。

---

## ⭐️ 所有権（Rustで一番大事な概念！）

所有権は Rust 最大の特徴です。他の多くの言語にはない仕組みなので、最初は戸惑うかもしれませんが、**Rustを学ぶ上で避けて通れない最重要ポイント**です。

ひとことで言うと、**「メモリ（データの置き場所）の管理をコンパイル時に自動チェックして、安全に使えるようにする仕組み」**です。

### まずはたとえ話で理解しよう

🎒 **リュックサックのたとえ**

- あなたはリュックサック（＝値）を持っています。リュックの持ち主はあなた1人です
- リュックを友達に**あげる**と、あなたはもう使えません → これが **ムーブ（移動）**
- リュックを友達に**ちょっと貸す**と、返してもらえばまた使えます → これが **借用（参照）**
- 友達に「中身を入れ替えていいよ」と貸す → これが **可変借用**

### 3つの基本ルール

| # | ルール | かんたんに言うと |
|---|--------|------------------|
| 1 | すべての値には**所有者（変数）が1つだけ** | リュックの持ち主は常に1人 |
| 2 | 所有者がスコープ（`{}`）を抜けると、値は**自動で片付けられる** | 持ち主がいなくなったら自動でゴミ箱行き |
| 3 | 所有権は**移動（ムーブ）できる** | 持ち主を別の人に変えられる |

### ムーブ（移動）を見てみよう

```rust
let s1 = String::from("hello");  // s1 が "hello" の所有者になる
let s2 = s1;                     // 所有権が s1 → s2 に移動！

// println!("{}", s1);  // ❌ エラー！s1はもう所有者じゃないので使えない
println!("{}", s2);     // ✅ OK！s2が今の所有者
```

**なぜこんな仕組みがあるの？**

もし s1 と s2 の両方が同じデータの所有者だと、プログラム終了時に**同じメモリを2回片付けようとしてバグ**になります（二重解放）。Rustはこれをコンパイル時に防いでくれるのです。

### 例外：自動的にコピーされる型

数値のような**サイズが小さくて単純な型**は、ムーブではなく**コピー（複製）**されます。コピーなので元の変数もそのまま使えます。

```rust
let x = 5;
let y = x;  // x の値がコピーされて y に入る（ムーブではない！）

println!("{}", x);  // ✅ OK（x も使える）
println!("{}", y);  // ✅ OK（y も使える）
```

**コピーされる型の例**: `i32`（整数）, `f64`（小数）, `bool`（真偽値）, `char`（文字）など

> **なぜ String はコピーされないの？** → String は中身のテキストデータをヒープ（メモリの広い領域）に持っていて、サイズが大きくなる可能性があるから。自動コピーするとパフォーマンスに影響するため、Rustでは明示的に `.clone()` を呼ばない限りコピーされません。

### 借用（参照）：所有権を渡さずに貸す

「値を使いたいけど、所有権は手放したくない」ときは **`&`（参照）** を使います。所有権はそのままで、一時的にデータを見せる（貸す）だけです。

```rust
fn print_length(s: &String) {  // &String = 「Stringへの参照」を受け取る
    println!("長さ: {}", s.len());
}  // ここで参照が終わるだけ。元の値は壊されない

let s = String::from("hello");
print_length(&s);  // &s = 「sの参照（読み取り専用の貸し出し）」を渡す
println!("{}", s);  // ✅ まだ使える！所有権は s のまま
```

### 可変参照：貸したデータを変更してもらう

参照は通常「読み取り専用」ですが、**`&mut`** をつけると「変更してもいいよ」という参照になります。

```rust
fn add_world(s: &mut String) {  // &mut = 「変更してもいい参照」
    s.push_str(" world");       // 文字列の末尾に " world" を追加
}

let mut s = String::from("hello");  // mut をつけて変更可能な変数にする
add_world(&mut s);                  // 変更可能な参照を渡す
println!("{}", s);                  // "hello world" と表示される
```

**大事な制限**: 可変参照は**同時に1つしか作れません**。これは複数箇所から同時にデータを変更して矛盾が起きる（データ競合）のを防ぐためです。

### 所有権のまとめ

| 概念 | かんたんな説明 | たとえ |
|------|---------------|--------|
| 所有権 | 値の「持ち主」。常に1つだけ | リュックの持ち主 |
| ムーブ | 所有権が別の変数に移る。元の変数は使えなくなる | リュックをあげる |
| コピー | 小さな型は自動で複製される。両方使える | リュックの中身をコピー |
| 借用 (`&`) | 読み取り専用で一時的に貸す | 「見せて」と借りる |
| 可変借用 (`&mut`) | 変更OKで一時的に貸す。同時に1つだけ | 「使っていいよ」と貸す |

> **所有権のおかげで、Rustはガベージコレクタ（自動メモリ回収の仕組み）なしで安全なメモリ管理を実現しています。** 最初は難しく感じますが、慣れると「コンパイラが守ってくれている安心感」が分かるようになります！
